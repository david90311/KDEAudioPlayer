//
//  RetryEventProducer.swift
//  AudioPlayer
//
//  Created by Kevin DELANNOY on 10/04/16.
//  Copyright Â© 2016 Kevin Delannoy. All rights reserved.
//

import Foundation

private extension Selector {
    /// The selector to call when the timer ticks.
    static let timerTicked = #selector(RetryEventProducer.timerTicked(_:))
}

/**
 *  A `RetryEventProducer` generates `RetryEvent`s when there should be a retry based on some
 *  information about interruptions.
 */
class RetryEventProducer: NSObject, EventProducer {
    /**
     `RetryEvent` is a list of event that can be generated by `RetryEventProducer`.

     - ShouldRetry: A retry is available.
     - ShouldSkip:  Retrying is no longer an option.
     */
    enum RetryEvent: Event {
        case ShouldRetry
        case ShouldSkip
    }

    /// The timer used to adjust quality
    private var timer: NSTimer?

    /// The listener that will be alerted a new event occured.
    weak var eventListener: EventListener?

    /// A boolean value indicating whether we're currently producing events or not.
    private var listening = false

    /// Interruption counter. It will be used to determine whether the quality should change.
    var retryCount = 0 {
        didSet {
            checkRetryCount()
        }
    }

    /// The maximum number of interruption before generating an event. Default value is 10.
    var maximumRetryCount = 10 {
        didSet {
            //TODO:
        }
    }

    /// The delay to wait before cancelling last retry and retrying. Default value is 10 seconds.
    var retryTimeout = NSTimeInterval(10) {
        didSet {
            //TODO:
        }
    }


    /**
     Stops producing events on deinitialization.
     */
    deinit {
        stopProducingEvents()
    }

    /**
     Starts listening to the player events.
     */
    func startProducingEvents() {
        guard !listening else {
            return
        }

        //Reset state
        resetState()

        //Saving that we're currently listening
        listening = true
    }

    /**
     Stops listening to the player events.
     */
    func stopProducingEvents() {
        guard listening else {
            return
        }

        timer?.invalidate()
        timer = nil

        //Saving that we're not listening anymore
        listening = false
    }

    /**
     Resets the state.
     */
    private func resetState() {
        /*retryCount = 0

        timer?.invalidate()
        timer = NSTimer.scheduledTimerWithTimeInterval(
            adjustQualityTimeInternal, target: self, selector: .timerTicked,
            userInfo: nil, repeats: false)*/
    }

    /**
     Checks that the interruption count is lower than `adjustQualityAfterInterruptionCount`. If it
     isn't, the function generates an event and reset its state.
     */
    private func checkRetryCount() {
        /*if retryCount >= adjustQualityAfterInterruptionCount && listening {
            //Now we need to stop the timer
            timer?.invalidate()

            //Calls the listener
            eventListener?.onEvent(QualityAdjustmentEvent.GoDown, generetedBy: self)

            //Reset state
            resetState()
        }*/
    }

    /**
     The quality adjuster ticked.
     */
    @objc private func timerTicked(_: AnyObject) {
        /*if retryCount == 0 {
            eventListener?.onEvent(RetryEvent.GoUp, generetedBy: self)
        }

        //Reset state
        resetState()*/
    }
}
